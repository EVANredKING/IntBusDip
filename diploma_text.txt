ВВЕДЕНИЕ

В современном мире информационные технологии прочно вошли во все аспекты деятельности предприятий. Каждая компания ищет способы оптимизировать свои процессы, сократить издержки и упростить работу с информацией. Особенно актуально это становится в условиях использования множества разнородных информационных систем, каждая из которых решает свои специфические задачи.

Многие производственные и инжиниринговые компании сталкиваются с проблемой разобщенности данных и процессов между ключевыми системами, такими как системы управления жизненным циклом изделия (PLM), системы планирования ресурсов предприятия (ERP) и другие специализированные приложения (например, системы типа ATOM, TeamCenter, IntBus, используемые в рамках данной работы). Отсутствие бесшовной интеграции приводит к ручному переносу данных, риску возникновения ошибок, несогласованности информации, задержкам в производственных и бизнес-процессах, а также усложняет получение комплексной аналитики для принятия управленческих решений. Невозможность оперативно обмениваться актуальной информацией между отделами и системами снижает общую эффективность и гибкость компании.

Проблемой, которую решает данная работа, является неэффективный обмен данными и отсутствие интеграции между ключевыми информационными системами предприятия (`ATOM`, `TeamCenter`, `IntBus`). Ручной ввод и перенос данных между этими системами не только трудоемок, но и чреват ошибками, что может привести к серьезным проблемам в планировании, производстве и управлении ресурсами. Отсутствие единого информационного пространства затрудняет контроль и анализ данных в реальном времени.

Для решения этой проблемы в рамках данной выпускной квалификационной работы разрабатывается программный продукт, предназначенный для автоматизации процессов обмена данными и интеграции между системами `ATOM`, `TeamCenter` и `IntBus`. Разрабатываемая система обеспечивает автоматическую загрузку, обработку и синхронизацию данных из различных источников (включая файлы специфических форматов, таких как `isxl`, `acn`, `coo`, `krl`, `otk`) и баз данных. Это позволяет создать единое информационное пространство, повысить достоверность данных, сократить время на выполнение рутинных операций и предоставить пользователям актуальную и согласованную информацию. Система также включает механизмы для мониторинга процессов интеграции и обработки возможных ошибок.

Актуальность темы выпускной квалификационной работы заключается в необходимости повышения эффективности бизнес-процессов предприятия за счет автоматизации обмена данными между критически важными информационными системами, что позволяет снизить трудозатраты, минимизировать ошибки и ускорить принятие решений на основе достоверных данных.

Объектом выпускной квалификационной работы является процесс интеграции и обмена данными между информационными системами `ATOM`, `TeamCenter` и `IntBus`.

Предметом выпускной квалификационной работы является программный модуль (приложение) для автоматизации синхронизации и интеграции данных между указанными системами.

Целью выпускной квалификационной работы является разработка программного продукта для автоматизации обмена данными между системами `ATOM`, `TeamCenter` и `IntBus`, обеспечивающего целостность, достоверность и своевременность передачи информации.

Для достижения поставленной цели необходимо решить следующие задачи:
*   провести анализ предметной области – изучить особенности информационных систем `ATOM`, `TeamCenter`, `IntBus` и форматы данных, используемые для обмена;
*   проанализировать существующие подходы и инструменты для интеграции корпоративных систем;
*   спроектировать архитектуру разрабатываемого программного продукта;
*   разработать структуру хранения промежуточных и служебных данных;
*   реализовать программные модули для извлечения, преобразования и загрузки данных (ETL) между системами;
*   разработать пользовательский интерфейс (если применимо) для управления и мониторинга процессов интеграции;
*   провести тестирование и отладку разработанного программного продукта;
*   подготовить документацию, включая руководство пользователя.

1 Теоретическое обоснование разрабатываемого программного продукта
    1.1 Описание предметной области

Предметной областью данной выпускной квалификационной работы является процесс обмена и интеграции данных между различными информационными системами, используемыми на предприятии, в частности, системами `ATOM`, `TeamCenter` и `IntBus`. Эти системы могут выполнять различные функции: `TeamCenter` часто используется как система управления жизненным циклом изделия (PLM), `IntBus` может представлять собой систему планирования ресурсов предприятия (ERP) или другую корпоративную систему, а `ATOM` — специализированное приложение для решения конкретных задач (например, технологической подготовки производства или управления ресурсами).

Ключевой особенностью предметной области является необходимость обеспечения согласованного и своевременного потока данных между этими разнородными системами. Данные могут включать конструкторско-технологическую информацию, данные о составе изделий, информацию о ресурсах, производственные задания, отчеты и другие сведения, необходимые для поддержки сквозных бизнес-процессов предприятия (например, проектирование, планирование, производство, контроль качества). Обмен данными часто осуществляется с использованием файлов специфических форматов (`isxl`, `acn`, `coo`, `krl`, `otk`) или через базы данных.

При разработке интеграционного решения важно глубоко понимать существующие процессы обмена данными ("AS-IS"), выявить узкие места, потребности пользователей в различных подразделениях и специфику форматов данных каждой из систем. Необходимо проанализировать текущие потоки информации, определить ключевые сущности и атрибуты данных, подлежащие синхронизации, а также правила их преобразования и валидации.

Разрабатываемый в рамках ВКР программный продукт предназначен для автоматизации этих процессов интеграции, устранения ручного ввода, снижения риска ошибок и обеспечения единого, достоверного информационного пространства для всех участников бизнес-процессов.

Для визуализации и анализа существующих процессов обмена данными ("AS-IS") могут использоваться методы структурного анализа и проектирования. На рисунке 1.1 представлена контекстная диаграмма IDEF0, описывающая текущее состояние взаимодействия систем (модель «AS-IS»). Для построения диаграмм используется программное средство Draw.io или аналогичное.

*[Здесь должна быть ссылка или само изображение Рисунок 1.1 – Контекстная диаграмма взаимодействия систем, модель «AS-IS»]*

Декомпозиция контекстной диаграммы, детализирующая основные этапы ручного или частично автоматизированного обмена данными между системами `ATOM`, `TeamCenter` и `IntBus` в текущем состоянии, представлена на рисунке 1.2.

*[Здесь должна быть ссылка или само изображение Рисунок 1.2 – Декомпозиция контекстной диаграммы, модель «AS-IS»]*

    1.2 Сравнительный анализ программ-аналогов

Анализ существующих решений для интеграции корпоративных систем и автоматизации обмена данными является важным шагом при разработке специализированного программного продукта. На рынке существует множество платформ и инструментов, предназначенных для решения подобных задач, от мощных корпоративных платформ до гибких open-source решений и заказных разработок. Ниже представлен краткий обзор нескольких категорий таких решений с примерами.

1.  **ETL-инструменты (Extract, Transform, Load):**
    *   **Примеры:** Talend Open Studio, Pentaho Data Integration (Kettle), Microsoft SSIS.
    *   **Преимущества:** Мощные средства для извлечения данных из различных источников (файлы, БД), их преобразования и загрузки в целевые системы. Часто имеют графический интерфейс для построения потоков данных. Open-source варианты бесплатны.
    *   **Недостатки:** Могут требовать значительных ресурсов для настройки и поддержки. Ориентированы в первую очередь на пакетную обработку данных, не всегда подходят для интеграции в реальном времени или сложных оркестровок процессов. Адаптация под очень специфичные форматы файлов (`isxl`, `acn`, `coo`, `krl`, `otk`) может потребовать дополнительной разработки.
2.  **ESB (Enterprise Service Bus) и iPaaS (Integration Platform as a Service):**
    *   **Примеры:** MuleSoft Anypoint Platform, WSO2 ESB (Open Source), Dell Boomi, Zapier.
    *   **Преимущества:** Предоставляют централизованную платформу для управления интеграциями между различными приложениями и сервисами. Поддерживают различные протоколы и форматы данных, часто имеют готовые коннекторы. Обеспечивают возможности мониторинга, управления ошибками, безопасности. iPaaS решения работают в облаке.
    *   **Недостатки:** Могут быть избыточными и дорогостоящими для решения локальной задачи интеграции нескольких конкретных систем. Требуют времени на освоение и настройку. Гибкость кастомизации под уникальные требования может быть ограничена возможностями платформы или требовать значительных усилий.
3.  **Пользовательские скрипты и фреймворки:**
    *   **Примеры:** Скрипты на Python (с библиотеками типа Pandas, SQLAlchemy), Java, PowerShell и т.д.
    *   **Преимущества:** Максимальная гибкость для реализации специфических требований и логики обработки данных. Полный контроль над процессом интеграции. Потенциально низкая стоимость внедрения (если есть ресурсы для разработки).
    *   **Недостатки:** Требуют квалифицированных разработчиков для создания и поддержки. Повышается риск ошибок при отсутствии должного тестирования и документирования. Масштабируемость и надежность зависят от качества реализации. Отсутствие готового интерфейса для мониторинга и управления (нужно разрабатывать отдельно).
4.  **Встроенные средства интеграции систем:**
    *   **Примеры:** Модули интеграции TeamCenter (например, T4S/T4EA для интеграции с SAP), API систем `ATOM` или `IntBus` (если они существуют и документированы).
    *   **Преимущества:** Часто обеспечивают наиболее "бесшовную" интеграцию с конкретной системой. Поддерживаются вендором системы.
    *   **Недостатки:** Могут быть дорогими. Функционал ограничен задачами, предусмотренными вендором. Интеграция с *другими* системами (не теми, для которых модуль предназначен) может быть затруднена или невозможна.

Анализ данных категорий решений позволяет выделить их основные характеристики. Выбор конкретного подхода зависит от масштаба задачи, бюджета, требований к гибкости, производительности и имеющихся ресурсов. Для задачи интеграции конкретных систем (`ATOM`, `TeamCenter`, `IntBus`) с их специфическими форматами данных и потоками, разработка специализированного приложения (как в данной ВКР) часто является оправданным компромиссом между гибкостью и стоимостью.

В таблице 1.1 представлен обобщенный сравнительный анализ рассмотренных подходов.

Таблица 1.1 – Сравнительный анализ подходов к интеграции систем

| Характеристика                      | ETL-инструменты        | ESB/iPaaS Платформы | Пользовательские скрипты | Встроенные средства систем | Разрабатываемое ПО (цель ВКР) |
| :---------------------------------- | :--------------------- | :----------------- | :----------------------- | :------------------------- | :---------------------------- |
| **Основное назначение**             | Пакетная обработка данных | Интеграция приложений/сервисов | Конкретная задача автоматизации | Интеграция с конкретной системой | Интеграция ATOM/TC/IntBus    |
| **Способ разработки/настройки**   | Граф. интерфейс/Конфиг. | Граф. интерфейс/Конфиг. | Программирование        | Конфигурация/API          | Программирование             |
| **Гибкость/Кастомизация**         | Средняя                | Средняя/Высокая    | Очень высокая           | Низкая/Средняя            | Высокая (в рамках задачи)   |
| **Стоимость**                       | Open Source/Коммерческая | Коммерческая/Подписка | Затраты на разработку  | Коммерческая лицензия     | Затраты на разработку        |
| **Порог вхождения**                 | Средний                | Средний/Высокий    | Зависит от сложности   | Зависит от системы        | Зависит от технолгий       |
| **Поддержка специфичных форматов** | Требует настройки/разработки | Через коннекторы/разработку | Требует разработки      | Ограниченная               | Целевая разработка          |
| **Масштабируемость**                | Средняя/Высокая        | Высокая            | Зависит от реализации  | Зависит от системы        | Зависит от архитектуры      |
| **Интерфейс управления**          | Есть (встроенный)      | Есть (встроенный)  | Требует разработки      | Есть (встроенный)         | Требует разработки          |

В результате сравнительного анализа было выявлено, что для решения специфической задачи интеграции систем `ATOM`, `TeamCenter` и `IntBus` с учетом уникальных форматов данных и требований к обработке, разработка собственного программного продукта является целесообразной. Разрабатываемое приложение должно:

*   Обеспечивать надежное чтение, обработку и запись данных в специфических форматах (`isxl`, `acn`, `coo`, `krl`, `otk`) и/или взаимодействие с БД систем.
*   Реализовывать требуемую бизнес-логику преобразования и синхронизации данных между `ATOM`, `TeamCenter` и `IntBus`.
*   Предоставлять возможности для мониторинга процесса интеграции и обработки ошибок.
*   Иметь продуманную архитектуру для возможности дальнейшей поддержки и развития.
*   Быть реализовано с использованием выбранных средств разработки (обоснование которых будет дано в разделе 1.5), позволяющих эффективно решить поставленные задачи.

    1.3 Моделирование проектируемой системы

После анализа существующего положения дел ("AS-IS") и определения требований к разрабатываемому программному продукту, необходимо смоделировать целевое состояние системы ("TO-BE"). Моделирование позволяет визуализировать, как проектируемая система будет функционировать и взаимодействовать с внешними элементами (другими системами, пользователями) после ее внедрения. Для моделирования используются стандартизированные нотации, такие как IDEF0 и UML.

Модель "TO-BE" описывает процесс автоматизированного обмена данными между системами `ATOM`, `TeamCenter` и `IntBus` с использованием разработанного программного продукта.

На рисунке 1.3 представлена контекстная диаграмма IDEF0, отражающая общую функцию проектируемой системы в ее окружении (модель «TO-BE»). Диаграмма показывает основные входы (данные из исходных систем), выходы (данные в целевые системы, отчеты, логи), управляющие воздействия (конфигурационные файлы, расписание запуска) и механизмы (разработанное ПО, аппаратные ресурсы). Для построения диаграмм используется программное средство Draw.io или аналогичное.

*[Здесь должна быть ссылка или само изображение Рисунок 1.3 – Контекстная диаграмма проектируемой системы, модель «TO-BE»]*

Декомпозиция контекстной диаграммы "TO-BE" представлена на рисунке 1.4. Она детализирует основные подпроцессы, выполняемые разрабатываемой системой, такие как извлечение данных, их преобразование в соответствии с заданными правилами, загрузка в целевые системы, а также процессы мониторинга и логирования.

*[Здесь должна быть ссылка или само изображение Рисунок 1.4 – Декомпозиция контекстной диаграммы, модель «TO-BE»]*

Для описания взаимодействия пользователей (если таковые предполагаются, например, администратор системы) с разрабатываемым программным продуктом используется диаграмма вариантов использования (Use Case Diagram) из нотации UML. Она показывает основных действующих лиц (акторов) и функции (варианты использования), которые они могут выполнять с помощью системы. Диаграмма вариантов использования представлена на рисунке 1.5.

*[Здесь должна быть ссылка или само изображение Рисунок 1.5 – Диаграмма вариантов использования проектируемой системы]*

    1.4 Разработка функциональных требований к программной системе

На данном этапе определяются конкретные требования к функциям, надежности, техническим средствам и документации разрабатываемого программного продукта, основной задачей которого является интеграция данных между системами `ATOM` (Django/Python), `TeamCenter` (Java/Maven) и `IntBus` (Django/Python). Особое внимание уделяется модулю синхронизации (предположительно `sync_app` в проекте `IntBus`), который выступает координатором обмена данными.

        1.4.1 Назначение программы

Назначение разрабатываемого интеграционного решения — автоматизация процессов обмена данными между приложениями `ATOM`, `TeamCenter` и `IntBus`. Цель — обеспечить консистентность и актуальность данных в этих разнородных системах (двух Django/SQLite и одной Java/H2) путем настройки, выполнения и мониторинга задач по извлечению, преобразованию и загрузке информации. Решение должно устранить необходимость ручного переноса данных, снизить количество ошибок и создать предпосылки для единого информационного пространства предприятия в части данных, обрабатываемых этими системами. Центральная логика интеграции и оркестрации процессов реализуется в рамках выделенного модуля (предположительно `sync_app` в `IntBus`).

        1.4.2 Требования к функциональным характеристикам

Программное решение (включая модуль `sync_app`) должно обеспечивать выполнение следующих функций:

*   **Конфигурирование интеграционных потоков:**
    *   Настройка параметров подключения к базам данных систем: SQLite для `ATOM` и `IntBus`, H2 для `TeamCenter`.
    *   Указание путей к каталогам с данными (`data/`) для обработки файлов.
    *   Определение правил и маппинга для преобразования данных между структурами БД и форматами файлов (включая `isxl`, `acn`, `coo`, `krl`, `otk`).
    *   Настройка расписания автоматического запуска интеграционных задач (например, через Celery для Django или внешний cron).
    *   (Возможно, через интерфейс `IntBus`) Управление конфигурациями задач.
*   **Выполнение интеграционных потоков:**
    *   Чтение данных из БД SQLite (`ATOM`, `IntBus`) и H2 (`TeamCenter`).
    *   Чтение и парсинг файлов указанных форматов из директорий `data/` (включая XML различных структур и Excel-файлы (.xlsx, .xls)).
    *   Преобразование данных в соответствии с настроенными правилами.
    *   Запись/обновление данных в БД SQLite и H2.
    *   Запись обработанных файлов (при необходимости).
    *   Надежная обработка ошибок на всех этапах (подключение, чтение, преобразование, запись) и их логирование.
*   **Мониторинг и Управление:**
    *   (Возможно, через интерфейс `IntBus`) Просмотр статуса выполнения интеграционных задач.
    *   Просмотр детальных логов выполнения и ошибок (файлы логов в `logs/`).
    *   (Возможно, через интерфейс `IntBus`) Ручной запуск/остановка отдельных интеграционных задач.
*   **Безопасность:**
    *   Безопасное хранение конфигурации, включая (при необходимости) учетные данные для доступа к БД или внешним системам.
    *   Аутентификация и авторизация доступа к функциям управления и мониторинга в интерфейсе `IntBus` (используя встроенные механизмы Django в `accounts/`).

        1.4.3 Требования к надежности

Надежность интеграционного решения обеспечивается выбором проверенных библиотек Python и Java, а также тщательным тестированием. Решение должно предусматривать:

*   Устойчивость к ошибкам подключения к БД (SQLite, H2) и файловой системе.
*   Корректную обработку ошибок парсинга файлов различных форматов.
*   Механизмы обработки ошибок при записи данных (например, нарушение ограничений целостности БД).
*   Обеспечение консистентности данных при выполнении многошаговых операций (по возможности, использование транзакций).
*   Исключение утечек ресурсов (память, соединения с БД, файловые дескрипторы) при длительной работе или обработке больших объемов данных.
*   Ведение информативных логов для быстрой диагностики и устранения неисправностей.

        1.4.4 Требования к составу и параметрам технических и программных средств

Для развертывания и функционирования всех компонентов системы (`ATOM`, `TeamCenter`, `IntBus` с `sync_app`) рекомендуется использовать серверные мощности или контейнерную среду (Docker) со следующими минимальными характеристиками (на каждый компонент или на общую среду, в зависимости от архитектуры развертывания):

Таблица 1.2 – Минимальные рекомендуемые системные требования (на компонент/контейнер)

| Параметр                  | Минимальное рекомендуемое значение                                    |
| :------------------------ | :-------------------------------------------------------------------- |
| Операционная система      | Linux (рекомендуется, основа для Docker-образов), Windows Server/Desktop |
| Процессор                 | от 2.00 ГГц (2+ ядра)                                                 |
| Оперативная память        | 2-4 Гб (зависит от конкретного приложения и объема данных)          |
| Место на жестком диске    | 1-2 Гб (для приложения, БД, логов, временных файлов)                  |
| Среда выполнения          | Python (версия из `requirements.txt`), Java JRE (версия из `pom.xml`/Dockerfile) |
| Сетевое подключение       | Доступность между компонентами системы, доступ к файловым ресурсам    |

        1.4.5 Требование к программной документации

*   **Среда выполнения:** Python (конкретная версия 3.x) с Django для `ATOM`/`IntBus`; Java (конкретная версия JRE/JDK) для `TeamCenter`.
*   **Зависимости:** Все библиотеки Python, указанные в `requirements.txt` для `ATOM` и `IntBus` (включая Django, драйверы БД, библиотеки для парсинга файлов). Все зависимости Java, указанные в `pom.xml` для `TeamCenter` (включая драйвер H2 JDBC, возможно Spring Boot/Framework).
*   **Базы данных:** Совместимость с SQLite (для `ATOM`/`IntBus`) и H2 Database Engine (для `TeamCenter`).
*   **Контейнеризация:** Корректная сборка и запуск в Docker с использованием предоставленных `Dockerfile`. Желательна совместимость с Docker Compose для упрощения развертывания всей системы.
*   **Форматы файлов:** Поддержка чтения и записи файлов форматов XML (различных структур) и Excel (.xlsx, .xls), а также стандартных (например, CSV, JSON, если используются).

Разработчиками предоставляется следующая документация:
*   **Пояснительная записка (данный документ).**
*   **Руководство администратора/оператора:** Описание развертывания (включая Docker), настройки конфигурационных файлов, запуска/остановки сервисов, мониторинга логов, выполнения ручных операций (если есть), решения типовых проблем.
*   **Техническое описание:** Описание архитектуры интеграционного решения, схемы потоков данных, структуры используемых БД (в части интеграции), описание ключевых алгоритмов модуля `sync_app`, описание конфигурационных файлов.
*   **README файлы:** В корне каждого проекта (`ATOM`, `TeamCenter`, `IntBus`) с описанием его назначения, инструкциями по сборке и запуску.
*   **Комментарии в коде:** Объяснение неочевидных участков кода, особенно в логике преобразования и синхронизации данных.

    1.5 Обоснование выбора средств реализации программной системы

Для разработки интеграционного решения между системами `ATOM`, `TeamCenter` и `IntBus` были выбраны следующие технологии:

	Основной язык и фреймворк для интеграционной логики (приложения `ATOM`, `IntBus`, модуль `sync_app`): Python и Django.
	СУБД для Python-приложений: SQLite.
	Язык и система сборки для компонента `TeamCenter`: Java и Maven.
	СУБД для Java-приложения: H2.
	Средство контейнеризации: Docker.
	Библиотека пользовательского интерфейса: React.

Преимущества Python и Django:
	Простота и читаемость Python: Ускоряет разработку и упрощает поддержку кода, что важно для сложной логики интеграции.
	Обширная экосистема Python: Наличие готовых библиотек для работы с данными (например, Pandas), XML/Excel (например, lxml, openpyxl), базами данных (SQLAlchemy, psycopg2, встроенная поддержка SQLite), что критично для задач извлечения и преобразования.
	Мощный фреймворк Django: Предоставляет ORM для работы с БД, систему аутентификации (`accounts/`), административный интерфейс (может использоваться для управления `sync_app` в `IntBus`), ускоряет разработку API и веб-интерфейсов, если они потребуются для управления или мониторинга.
	Зрелость и большое сообщество: Обеспечивает доступность документации, решений типовых проблем и поддержки.

Преимущества SQLite:
	Простота: Не требует установки и администрирования отдельного сервера БД; данные хранятся в одном файле, что упрощает развертывание и резервное копирование.
	Легковесность: Минимальное потребление системных ресурсов.
	Удобство для разработки и тестирования: Отлично подходит для локальной разработки и для приложений (`ATOM`, `IntBus` в данном случае), где не требуется высокая производительность при множестве одновременных записей.

Преимущества Java и Maven:
	Надежность и производительность Java: Традиционно используется для создания стабильных и производительных корпоративных систем, какой, вероятно, является `TeamCenter`. Строгая типизация помогает выявлять ошибки на этапе компиляции.
	Платформенная независимость Java (JVM): Позволяет запускать `TeamCenter` на различных операционных системах без перекомпиляции.
	Стандартная система сборки Maven (`pom.xml`): Эффективно управляет зависимостями Java-проекта, автоматизирует процесс сборки, тестирования и упаковки, обеспечивая консистентность.
	Существующая кодовая база `TeamCenter`: Использование Java для интеграции с системой, уже написанной на Java, является естественным выбором, упрощающим взаимодействие.

Преимущества H2:
	Встраиваемость и легковесность: Удобна для Java-приложений (`TeamCenter`), так как может работать в том же процессе JVM без необходимости внешнего сервера БД.
	Хорошая интеграция с Java: Написана на Java, легко взаимодействует через стандартный JDBC API.
	Поддержка стандартного SQL: Обеспечивает совместимость с распространенными SQL-запросами.

Преимущества Docker:
	Изоляция окружения: Упаковка каждого приложения (`ATOM`, `TeamCenter`, `IntBus`) в отдельный контейнер (`Dockerfile`) со всеми его зависимостями гарантирует отсутствие конфликтов и одинаковое поведение вне зависимости от хост-системы.
	Воспроизводимость: Обеспечивает идентичность окружения на всех этапах жизненного цикла ПО (разработка, тестирование, эксплуатация).
	Упрощение развертывания и управления: Позволяет легко развернуть, запустить, остановить и обновить всю систему из нескольких компонентов, особенно при использовании Docker Compose.
	Масштабируемость: Упрощает горизонтальное масштабирование отдельных сервисов при необходимости увеличения нагрузки.

Преимущества React:
	Компонентный подход: Позволяет создавать переиспользуемые и изолированные UI-компоненты, упрощая разработку и поддержку сложных интерфейсов (вероятно, используется в `TeamCenter/frontend/`).
	Виртуальный DOM: Обеспечивает высокую производительность отрисовки интерфейса за счет минимизации прямых манипуляций с реальным DOM.
	Большое сообщество и экосистема: Множество готовых библиотек, инструментов и доступной документации для решения различных задач фронтенд-разработки.
	Декларативный стиль: Упрощает понимание кода и отладку интерфейсов.

    1.6 Вывод по разделу

[Текст для вывода по разделу 1, обобщающий анализ, выбор и моделирование]

2 Разработка программного продукта

В данном разделе описывается процесс разработки программного продукта для интеграции систем `ATOM`, `TeamCenter` и `IntBus`. Описывается архитектура решения, структура обрабатываемых данных, ключевые алгоритмы синхронизации, пользовательский интерфейс (если применимо для управления интеграцией), а также процесс отладки, тестирования и руководство пользователя по эксплуатации интеграционного модуля.

    2.1 Разработка архитектуры программной системы

Архитектура разработанного интеграционного решения построена по принципу распределенной системы, состоящей из трех основных компонентов: `ATOM`, `TeamCenter` и `IntBus`. Центральным координирующим звеном является приложение `sync_app`, реализованное как Django-приложение в рамках системы `IntBus`, которое отвечает за оркестрацию потоков данных между всеми системами.

Общая архитектура системы представлена на рисунке 2.1.

*[Здесь должна быть Рисунок 2.1 – Архитектурная схема интеграционного решения]*

Таблица 2.1 – Основные компоненты системы и их техническая реализация

| Компонент | Технологический стек | Назначение | Структура | Роль в интеграции |
|:----------|:---------------------|:-----------|:----------|:------------------|
| ATOM | Django 4.0+, Python 3.8+, SQLite | Система управления номенклатурой и ЛСИ | atom_project/ - проект Django, accounts/ - модуль авторизации, БД SQLite, Docker-контейнер | Основной источник данных о номенклатуре и ЛСИ |
| TeamCenter | Java 17, Spring Boot, Maven, React, H2 Database | Система управления инженерными данными | Backend: Spring Boot с REST API, Frontend: React, БД H2, Docker-контейнер | Источник и приемник инженерных данных |
| IntBus | Django 4.0+, Python 3.8+, SQLite | Система просмотра номенклатуры и координации обмена | intbus_project/ - проект Django, nomenclature/ - приложение просмотра, sync_app/ - модуль интеграции, Docker-контейнер | Центральный узел координации |

Таблица 2.2 – Функциональность модуля sync_app как ядра интеграции

| Функциональный блок | Компоненты | Описание |
|:--------------------|:-----------|:---------|
| API для обмена данными | sync_data, send_to_atom, send_to_teamcenter, check_connection | Эндпоинты для приема и отправки данных, проверки доступности систем |
| Управление маппингом полей | Модель MappingField, get_mapping_table, apply_mapping | Хранение и применение правил соответствия полей между системами |
| Синхронизация данных | Обработка JSON, трансформация данных, обновление записей | Процессы извлечения, преобразования и загрузки данных |
| Логирование и обработка ошибок | Запись в файлы logs/, обработчики исключений | Отслеживание процессов и обработка ошибок |

Таблица 2.3 – Механизмы взаимодействия между компонентами системы

| Механизм | Технологии | Особенности реализации |
|:---------|:-----------|:------------------------|
| HTTP/REST API | JSON, Django REST framework, Spring Boot REST | Основной способ обмена данными, аутентификация через API-ключи |
| Файловый обмен | Директории data/, XML, Excel | Обмен неструктурированными данными, парсинг файлов |
| Доступ к базам данных | SQLite (ATOM, IntBus), H2 (TeamCenter) | Прямой доступ к БД как резервный вариант взаимодействия |

Таблица 2.4 – Ключевые API-эндпоинты интеграции

| Система | Эндпоинт | Метод | Описание |
|:--------|:---------|:------|:---------|
| IntBus | /sync_app/sync_data | POST | Прием данных от внешних систем |
| IntBus | /sync_app/send_to_atom | POST | Отправка данных в ATOM |
| IntBus | /sync_app/send_to_teamcenter | POST | Отправка данных в TeamCenter |
| IntBus | /sync_app/check_connection | GET | Проверка доступности систем |
| TeamCenter | /api/sync-from-intbus | POST | Прием данных из IntBus |
| TeamCenter | /api/intbus/send | POST | Отправка данных в IntBus |
| TeamCenter | /api/intbus/send-lsi | POST | Отправка данных ЛСИ в IntBus |

Таблица 2.5 – Компоненты инфраструктуры и безопасности

| Компонент | Реализация | Назначение |
|:----------|:-----------|:-----------|
| Контейнеризация | Docker | Изоляция компонентов, упрощение развертывания |
| Конфигурация | settings.py (Django), application.properties (Spring) | Настройка параметров работы приложений |
| Аутентификация | Django Auth, Spring Security | Защита доступа к API и интерфейсам |
| Логирование | Директории logs/ | Отслеживание активности и диагностика ошибок |

**Процесс интеграции данных:**

Процесс интеграции между системами реализован по принципу издатель-подписчик, где:
1. Система-источник отправляет данные через API в модуль `sync_app`
2. Модуль `sync_app` обрабатывает данные, применяет правила маппинга полей
3. Преобразованные данные отправляются в целевую систему
4. Обновляются флаги синхронизации, записывается статус в лог

**Схема развертывания:**

Архитектура предусматривает возможность развертывания как на одном сервере (все три контейнера Docker на одной машине), так и в распределенной среде (каждый контейнер на отдельном сервере). Связь между контейнерами осуществляется через сетевые интерфейсы Docker или напрямую через сеть при распределенном развертывании.

    2.2 Разработка структуры данных

Интеграционное решение оперирует данными, хранящимися в базах данных систем `ATOM`, `TeamCenter`, `IntBus`, а также данными, передаваемыми через файлы XML и Excel.

**Структура баз данных:**
Основной обмен структурированными данными происходит через подключение к базам данных: SQLite для `ATOM` и `IntBus`, H2 для `TeamCenter`. Модуль `sync_app` считывает данные из таблиц одной системы (источника), трансформирует и записывает в таблицы другой системы (приемника).

Физическая схема ключевых таблиц баз данных, участвующих в интеграции, и связей между ними (в рамках одной БД) представлена на рисунке 2.2.

*[Здесь должна быть Рисунок 2.2 – Физическая схема ключевых таблиц БД (упрощенная ERD)]*

**Структура файлов обмена:**
Для передачи данных, не хранящихся в БД, или для обмена со сторонними системами используются файлы:
*   **XML:** Структурированные данные, часто используются для передачи сложных иерархических структур, таких как состав изделия (BOM) [`ИСТОЧНИК` для `sync_app`]. Структура определяется XSD-схемой (см. Приложение X).
*   **Excel (.xlsx, .xls):** Табличные данные, удобны для импорта/экспорта справочников или отчетов [`ИСТОЧНИК` или `ПРИЕМНИК` для `sync_app`]. (см. Приложение Y).
Модуль `sync_app` отвечает за парсинг входящих файлов из директорий `data/` и формирование исходящих файлов.

**Описание сущностей баз данных:**
Ниже представлены таблицы с описанием основных сущностей (таблиц) и их атрибутов (полей) для каждой из баз данных, участвующих в интеграции. Указано, какие поля предположительно являются источником (`[ИСТОЧНИК]`) или приемником (`[ПРИЕМНИК]`) данных в процессе синхронизации. **Внимание: Названия таблиц и полей являются примерами и должны быть заменены на реальные имена из баз данных проекта.**

***База данных ATOM (SQLite)***

Таблица 2.9 – Сущность "Пользователи" (`auth_user` - стандартная Django)

| Атрибут (Поле) | Тип данных (SQLite) | Описание                                      |
| :------------- | :------------------ | :-------------------------------------------- |
| `id`           | INTEGER PRIMARY KEY | Идентификатор пользователя                    |
| `username`     | VARCHAR(150) UNIQUE | Имя пользователя (логин) [`ИСТОЧНИК`]         |
| `first_name`   | VARCHAR(150)        | Имя [`ИСТОЧНИК`]                             |
| `last_name`    | VARCHAR(150)        | Фамилия [`ИСТОЧНИК`]                         |
| `email`        | VARCHAR(254)        | Электронная почта [`ИСТОЧНИК`]                |
| `is_active`    | BOOLEAN             | Флаг активности пользователя                  |
| `password`     | VARCHAR(128)        | Хеш пароля (не передается)                    |
| `is_superuser` | BOOLEAN             | Флаг суперпользователя                        |
| `is_staff`     | BOOLEAN             | Флаг персонала                                |
| `date_joined`  | DATETIME            | Дата регистрации                              |
| `last_login`   | DATETIME            | Дата последнего входа                         |

Таблица 2.10 – Сущность "Объект номенклатуры ATOM" (`accounts_nomenclature` - [`ИСТОЧНИК` данных для IntBus/TC])

| Атрибут (Поле)        | Тип данных (SQLite) | Описание                                          |
| :-------------------- | :------------------ | :------------------------------------------------ |
| `id`                  | INTEGER PRIMARY KEY | Уникальный идентификатор номенклатуры             |
| `abbreviation`        | VARCHAR(100)        | Аббревиатура [`ИСТОЧНИК`]                        |
| `short_name`          | VARCHAR(255)        | Краткое наименование [`ИСТОЧНИК`]                 |
| `full_name`           | VARCHAR(255)        | Полное наименование [`ИСТОЧНИК`]                  |
| `internal_code`       | VARCHAR(100)        | Внутренний код [`ИСТОЧНИК`]                      |
| `cipher`              | VARCHAR(100)        | Шифр [`ИСТОЧНИК`]                                |
| `ekps_code`           | VARCHAR(100)        | Код ЕКПС [`ИСТОЧНИК`]                            |
| `kvt_code`            | VARCHAR(100)        | Код КВТ [`ИСТОЧНИК`]                             |
| `drawing_number`      | VARCHAR(100)        | Номер чертежа [`ИСТОЧНИК`]                       |
| `effective_date`      | DATE                | Дата вступления в силу [`ИСТОЧНИК`]              |
| `uuid`                | VARCHAR(36)         | Уникальный идентификатор UUID [`ИСТОЧНИК`]       |
| `archived`            | BOOLEAN             | Флаг архивации [`ИСТОЧНИК`]                      |
| `checksum`            | VARCHAR(255)        | Контрольная сумма [`ИСТОЧНИК`]                   |
| `classifier_unique_code` | VARCHAR(100)     | Уникальный код классификатора [`ИСТОЧНИК`]      |
| `deletion_mark`       | BOOLEAN             | Отметка об удалении [`ИСТОЧНИК`]                 |
| `spk_nomenclature_type` | VARCHAR(100)      | Тип номенклатуры СПК [`ИСТОЧНИК`]               |

Таблица 2.11 – Сущность "Логическая структура изделия ATOM" (`accounts_lsi` - [`ИСТОЧНИК` данных для IntBus/TC])

| Атрибут (Поле)                   | Тип данных (SQLite) | Описание                                          |
| :------------------------------- | :------------------ | :------------------------------------------------ |
| `id`                             | INTEGER PRIMARY KEY | Уникальный идентификатор записи ЛСИ               |
| `cipher`                         | VARCHAR(100)        | Шифр [`ИСТОЧНИК`]                                |
| `code_1` - `code_5`              | VARCHAR(255)        | Коды (1-5) [`ИСТОЧНИК`]                          |
| `deletion_mark`                  | BOOLEAN             | Отметка об удалении [`ИСТОЧНИК`]                 |
| `dns`                            | VARCHAR(255)        | ДНС [`ИСТОЧНИК`]                                 |
| `drawing_number`                 | VARCHAR(255)        | Номер чертежа [`ИСТОЧНИК`]                       |
| `group_indicator`                | BOOLEAN             | Индикатор группы [`ИСТОЧНИК`]                    |
| `lkn`                            | VARCHAR(255)        | ЛКН [`ИСТОЧНИК`]                                 |
| `modification_code`              | VARCHAR(255)        | Код модификации [`ИСТОЧНИК`]                     |
| `object_type_code`               | VARCHAR(36)         | Код типа объекта [`ИСТОЧНИК`]                    |
| `parent_record_id`               | VARCHAR(255)        | ID родительской записи [`ИСТОЧНИК`]              |
| `position_code`                  | VARCHAR(255)        | Код позиции [`ИСТОЧНИК`]                         |
| `position_in_staff_structure_type` | VARCHAR(255)      | Тип позиции в структуре [`ИСТОЧНИК`]             |
| `position_name`                  | VARCHAR(255)        | Наименование позиции [`ИСТОЧНИК`]                |
| `quantity`                       | INTEGER             | Количество [`ИСТОЧНИК`]                          |
| `specialty`                      | VARCHAR(255)        | Специальность [`ИСТОЧНИК`]                       |
| `uuid`                           | VARCHAR(36)         | Уникальный идентификатор UUID [`ИСТОЧНИК`]       |

***База данных TeamCenter (H2)***

Таблица 2.12 – Сущность "Элемент ЛСИ TeamCenter" (`lsi_items` - [`ИСТОЧНИК` или `ПРИЕМНИК`])

| Атрибут (Поле)        | Тип данных (H2)      | Описание                                          |
| :-------------------- | :------------------- | :------------------------------------------------ |
| `id`                  | BIGINT PRIMARY KEY   | Уникальный идентификатор элемента TC              |
| `component_id`        | VARCHAR(255) UNIQUE  | Идентификатор компонента [`ИСТОЧНИК`/`ПРИЕМНИК`]  |
| `item_id`             | VARCHAR(255) UNIQUE  | Идентификатор элемента [`ИСТОЧНИК`/`ПРИЕМНИК`]    |
| `name`                | VARCHAR(255)         | Наименование [`ИСТОЧНИК`/`ПРИЕМНИК`]              |
| `description`         | VARCHAR(2000)        | Описание [`ИСТОЧНИК`/`ПРИЕМНИК`]                  |
| `revision`            | VARCHAR(50)          | Ревизия [`ИСТОЧНИК`/`ПРИЕМНИК`]                   |
| `type`                | VARCHAR(255)         | Тип элемента [`ИСТОЧНИК`/`ПРИЕМНИК`]              |
| `release_status`      | VARCHAR(255)         | Статус выпуска [`ИСТОЧНИК`/`ПРИЕМНИК`]            |
| `unit_of_measure`     | VARCHAR(50)          | Единица измерения [`ИСТОЧНИК`/`ПРИЕМНИК`]         |
| `owner`               | VARCHAR(255)         | Владелец [`ИСТОЧНИК`]                             |
| `creation_date`       | TIMESTAMP            | Дата создания [`ИСТОЧНИК`]                        |
| `last_modified_date`  | TIMESTAMP            | Дата последнего изменения [`ИСТОЧНИК` для дельты] |
| `last_modified_user`  | VARCHAR(255)         | Пользователь-модификатор [`ИСТОЧНИК`]             |
| `project_list`        | VARCHAR(255)         | Список проектов [`ИСТОЧНИК`/`ПРИЕМНИК`]           |

Таблица 2.13 – Сущность "Объект номенклатуры TeamCenter" (`nomenclatures` - [`ИСТОЧНИК` или `ПРИЕМНИК`])

| Атрибут (Поле)        | Тип данных (H2)      | Описание                                          |
| :-------------------- | :------------------- | :------------------------------------------------ |
| `id`                  | BIGINT PRIMARY KEY   | Уникальный идентификатор номенклатуры             |
| `component_id`        | VARCHAR(255) UNIQUE  | Идентификатор компонента [`ИСТОЧНИК`/`ПРИЕМНИК`]  |
| `item_id`             | VARCHAR(255) UNIQUE  | Идентификатор элемента [`ИСТОЧНИК`/`ПРИЕМНИК`]    |
| `name`                | VARCHAR(255)         | Наименование [`ИСТОЧНИК`/`ПРИЕМНИК`]              |
| `description`         | VARCHAR(2000)        | Описание [`ИСТОЧНИК`/`ПРИЕМНИК`]                  |
| `abbreviation`        | VARCHAR(50)          | Аббревиатура [`ИСТОЧНИК`/`ПРИЕМНИК`]              |
| `short_name`          | VARCHAR(255)         | Краткое наименование [`ИСТОЧНИК`/`ПРИЕМНИК`]      |
| `full_name`           | VARCHAR(255)         | Полное наименование [`ИСТОЧНИК`/`ПРИЕМНИК`]       |
| `internal_code`       | VARCHAR(100)         | Внутренний код [`ИСТОЧНИК`/`ПРИЕМНИК`]            |
| `cipher`              | VARCHAR(100)         | Шифр [`ИСТОЧНИК`/`ПРИЕМНИК`]                      |
| `ekps_code`           | VARCHAR(100)         | Код ЕКПС [`ИСТОЧНИК`/`ПРИЕМНИК`]                  |
| `kvt_code`            | VARCHAR(100)         | Код КВТ [`ИСТОЧНИК`/`ПРИЕМНИК`]                   |
| `drawing_number`      | VARCHAR(100)         | Номер чертежа [`ИСТОЧНИК`/`ПРИЕМНИК`]             |
| `type_of_nomenclature`| VARCHAR(100)         | Тип номенклатуры [`ИСТОЧНИК`/`ПРИЕМНИК`]          |
| `revision`            | VARCHAR(50)          | Ревизия [`ИСТОЧНИК`/`ПРИЕМНИК`]                   |
| `type`                | VARCHAR(255)         | Тип элемента [`ИСТОЧНИК`/`ПРИЕМНИК`]              |
| `release_status`      | VARCHAR(255)         | Статус выпуска [`ИСТОЧНИК`/`ПРИЕМНИК`]            |
| `unit_of_measure`     | VARCHAR(50)          | Единица измерения [`ИСТОЧНИК`/`ПРИЕМНИК`]         |
| `owner`               | VARCHAR(255)         | Владелец [`ИСТОЧНИК`]                             |
| `creation_date`       | TIMESTAMP            | Дата создания [`ИСТОЧНИК`]                        |
| `last_modified_date`  | TIMESTAMP            | Дата последнего изменения [`ИСТОЧНИК` для дельты] |
| `last_modified_user`  | VARCHAR(255)         | Пользователь-модификатор [`ИСТОЧНИК`]             |
| `project_list`        | VARCHAR(255)         | Список проектов [`ИСТОЧНИК`/`ПРИЕМНИК`]           |

***База данных IntBus (SQLite)***

Таблица 2.14 – Сущность "Пользователи" (`auth_user` - стандартная Django)
*Структура аналогична Таблице 2.9. Может быть [`ПРИЕМНИКОМ`], если создаются пользователи из других систем.*

Таблица 2.15 – Сущность "Номенклатура" (`nomenclature_nomenclature` - [`ПРИЕМНИК` данных из ATOM/TC])

| Атрибут (Поле)   | Тип данных (SQLite) | Описание                                          |
| :--------------- | :------------------ | :------------------------------------------------ |
| `id`             | INTEGER PRIMARY KEY | Уникальный идентификатор номенклатуры IntBus      |
| `apikey`         | VARCHAR(255)        | API-ключ [`ПРИЕМНИК`]                             |
| `data`           | TEXT                | Данные в JSON-формате [`ПРИЕМНИК`]                |
| `sender`         | VARCHAR(255)        | Отправитель [`ПРИЕМНИК`]                          |
| `sent_to_atom`   | BOOLEAN             | Флаг отправки в ATOM [`ПРИЕМНИК`]                 |
| `sent_to_teamcenter` | BOOLEAN         | Флаг отправки в TeamCenter [`ПРИЕМНИК`]           |
| `code`           | VARCHAR(100)        | Код номенклатуры [`ПРИЕМНИК` из ATOM/TC]          |
| `name`           | VARCHAR(255)        | Наименование [`ПРИЕМНИК` из ATOM/TC]              |

Таблица 2.16 – Сущность "ЛСИ" (`nomenclature_lsi` - [`ПРИЕМНИК` данных из ATOM/TC])

| Атрибут (Поле)   | Тип данных (SQLite) | Описание                                          |
| :--------------- | :------------------ | :------------------------------------------------ |
| `id`             | INTEGER PRIMARY KEY | Уникальный идентификатор ЛСИ IntBus               |
| `apikey`         | VARCHAR(255)        | API-ключ [`ПРИЕМНИК`]                             |
| `data`           | TEXT                | Данные в JSON-формате [`ПРИЕМНИК`]                |
| `sender`         | VARCHAR(255)        | Отправитель [`ПРИЕМНИК`]                          |
| `sent_to_atom`   | BOOLEAN             | Флаг отправки в ATOM [`ПРИЕМНИК`]                 |
| `sent_to_teamcenter` | BOOLEAN         | Флаг отправки в TeamCenter [`ПРИЕМНИК`]          |
| `code`           | VARCHAR(100)        | Код ЛСИ [`ПРИЕМНИК` из ATOM/TC]                   |
| `name`           | VARCHAR(255)        | Наименование [`ПРИЕМНИК` из ATOM/TC]              |

Таблица 2.17 – Сущность "ЛСИ из TeamCenter" (`nomenclature_teamcenterlsi` - [`ПРИЕМНИК` данных из TC])

| Атрибут (Поле)                   | Тип данных (SQLite) | Описание                                          |
| :------------------------------- | :------------------ | :------------------------------------------------ |
| `id`                             | INTEGER PRIMARY KEY | Уникальный идентификатор записи                   |
| `apikey`                         | VARCHAR(255)        | API-ключ [`ПРИЕМНИК`]                             |
| `sender`                         | VARCHAR(255)        | Отправитель [`ПРИЕМНИК`]                          |
| `created_at`                     | DATETIME            | Дата создания [`ПРИЕМНИК`]                        |
| `updated_at`                     | DATETIME            | Дата обновления [`ПРИЕМНИК`]                      |
| `position_name`                  | VARCHAR(255)        | Наименование позиции [`ПРИЕМНИК` из TC]          |
| `uuid`                           | VARCHAR(100)        | UUID [`ПРИЕМНИК` из TC]                          |
| `drawing_number`                 | VARCHAR(255)        | Номер чертежа [`ПРИЕМНИК` из TC]                 |
| `dns`                            | TEXT                | ДНС [`ПРИЕМНИК` из TC]                           |
| `code_1` - `code_5`              | VARCHAR(100)        | Коды (1-5) [`ПРИЕМНИК` из TC]                    |
| `cipher`                         | VARCHAR(100)        | Шифр [`ПРИЕМНИК` из TC]                          |
| `deletion_mark`                  | BOOLEAN             | Отметка об удалении [`ПРИЕМНИК` из TC]          |
| `group_indicator`                | VARCHAR(100)        | Индикатор группы [`ПРИЕМНИК` из TC]             |
| `lkn`                            | VARCHAR(100)        | ЛКН [`ПРИЕМНИК` из TC]                          |
| `modification_code`              | VARCHAR(100)        | Код модификации [`ПРИЕМНИК` из TC]              |
| `object_type_code`               | VARCHAR(100)        | Код типа объекта [`ПРИЕМНИК` из TC]             |
| `parent_record_id`               | INTEGER             | ID родительской записи [`ПРИЕМНИК` из TC]       |
| `position_code`                  | VARCHAR(100)        | Код позиции [`ПРИЕМНИК` из TC]                  |
| `position_in_staff_structure_type` | VARCHAR(100)      | Тип позиции в структуре [`ПРИЕМНИК` из TC]      |
| `quantity`                       | FLOAT               | Количество [`ПРИЕМНИК` из TC]                   |
| `specialty`                      | VARCHAR(100)        | Специальность [`ПРИЕМНИК` из TC]                |
| `extra_data`                     | TEXT                | Дополнительные данные [`ПРИЕМНИК`]               |
| `sent_to_atom`                   | BOOLEAN             | Флаг отправки в ATOM [`ПРИЕМНИК`]                |

Таблица 2.18 – Сущность "Маппинг полей" (`sync_app_mappingfield` - для настройки синхронизации)

| Атрибут (Поле)    | Тип данных (SQLite) | Описание                                      |
| :---------------- | :------------------ | :-------------------------------------------- |
| `id`              | INTEGER PRIMARY KEY | Уникальный идентификатор маппинга             |
| `source_system`   | VARCHAR(50)         | Система-источник                              |
| `target_system`   | VARCHAR(50)         | Система-приемник                              |
| `data_type`       | VARCHAR(50)         | Тип данных                                    |
| `source_field`    | VARCHAR(255)        | Поле источника                                |
| `target_field`    | VARCHAR(255)        | Поле приемника                                |
| `is_active`       | BOOLEAN             | Активность маппинга                           |

    2.3 Конструирование пользовательского интерфейса

Пользовательский интерфейс для управления и мониторинга интеграционными процессами может быть реализован несколькими способами:

1.  **Административный интерфейс Django (`IntBus`):** Стандартный интерфейс Django может быть расширен для:
    *   Просмотра и редактирования конфигурации интеграционных задач (параметры подключения, маппинг, расписание).
    *   Просмотра статуса выполнения задач (успешно, ошибка, в процессе).
    *   Просмотра логов выполнения задач.
    *   Ручного запуска/остановки задач.
    На рисунке 2.3 показан пример раздела управления интеграцией в админ-панели `IntBus`.

    *[Здесь должна быть Рисунок 2.3 – Интерфейс управления интеграцией (Django Admin)]*

2.  **Frontend на React (`TeamCenter`):** Если `TeamCenter` имеет пользовательский интерфейс на React (судя по папке `frontend/`), он может быть доработан для отображения статуса синхронизации данных, релевантных для пользователя `TeamCenter`. На рисунке 2.4 показан пример виджета статуса интеграции.

    *[Здесь должна быть Рисунок 2.4 – Виджет статуса интеграции (React Frontend)]*

3.  **Отсутствие выделенного UI:** В простейшем случае управление может осуществляться через редактирование конфигурационных файлов и анализ лог-файлов напрямую, без графического интерфейса.

В данной реализации предполагается использование [Выбрать вариант 1, 2 или 3, или их комбинацию, в зависимости от реальной реализации].

    2.4 Схемы алгоритма программы и подпрограмм

Основным алгоритмом, реализуемым модулем `sync_app`, является процесс ETL (Extract, Transform, Load) для каждого настроенного потока данных.

**Общая схема алгоритма интеграции (ETL):**
1.  **Инициализация:** Загрузка конфигурации для конкретного потока данных (источник, приемник, правила трансформации).
2.  **Извлечение (Extract):**
    *   Подключение к источнику (БД или чтение файла).
    *   Получение данных (SQL-запрос или парсинг файла).
    *   Обработка ошибок подключения/чтения.
3.  **Преобразование (Transform):**
    *   Валидация извлеченных данных.
    *   Применение правил маппинга и преобразования форматов.
    *   Обогащение данных (если необходимо).
    *   Обработка ошибок трансформации.
4.  **Загрузка (Load):**
    *   Подключение к приемнику (БД или формирование файла).
    *   Запись/обновление данных (SQL INSERT/UPDATE или запись файла).
    *   Обработка ошибок записи (включая контроль целостности).
5.  **Логирование:** Запись информации о ходе выполнения, успешно обработанных записях, возникших ошибках.
6.  **Завершение:** Закрытие соединений, фиксация транзакций (если применимо).

Схема основного алгоритма ETL представлена на рисунке 2.5.

*[Здесь должна быть Рисунок 2.5 – Блок-схема основного алгоритма ETL]*

**Примеры схем подпрограмм:**

*   **Схема алгоритма парсинга XML файла:** Показывает шаги чтения XML, навигации по дереву документа (DOM или SAX), извлечения данных из нужных тегов и атрибутов, обработки ошибок парсинга. Представлена на рисунке 2.6.

    *[Здесь должна быть Рисунок 2.6 – Блок-схема алгоритма парсинга XML]*

*   **Схема алгоритма трансформации данных "Изделие":** Детализирует шаги преобразования данных для сущности "Изделие" согласно правилам из Таблицы 2.2 (маппинг полей, преобразование единиц измерения и т.д.). Представлена на рисунке 2.7.

    *[Здесь должна быть Рисунок 2.7 – Блок-схема алгоритма трансформации "Изделие"]*

*   **Схема алгоритма обработки ошибок:** Показывает, как система реагирует на разные типы ошибок (ошибка подключения, ошибка данных, ошибка записи) – логирование, откат транзакции, уведомление администратора (если настроено). Представлена на рисунке 2.8.

    *[Здесь должна быть Рисунок 2.8 – Блок-схема алгоритма обработки ошибок]*

**Расширенные схемы авторизации для Django-систем:**

Авторизация является критически важным элементом для обеспечения безопасности в системах `ATOM` и `IntBus`. Обе системы построены на фреймворке Django и используют сходные механизмы авторизации. Рассмотрим подробные схемы этих механизмов:

**Схема авторизации в ATOM:**
```
[Начало]
   │
   ├──► [Проверка текущей сессии] ──► [Пользователь уже авторизован?]
   │                                      │
   │                                      ├─ Да ──► [Перенаправление на главную]
   │                                      │
   │                                      └─ Нет ──► [Отображение формы логина]
   │
   ├──► [Пользователь отправляет форму (POST)]
   │
   ├──► [Проверка заполнения полей] ──► [Поля заполнены?]
   │                                       │
   │                                       ├─ Нет ──► [Ошибка валидации формы] ──► [Возврат формы с ошибками]
   │                                       │
   │                                       └─ Да ──► [Поиск пользователя в БД]
   │
   ├──► [Пользователь найден?]
   │         │
   │         ├─ Нет ──► [Ошибка "Пользователь не существует"] ──► [Возврат формы с ошибкой]
   │         │
   │         └─ Да ──► [Проверка пароля]
   │
   ├──► [Пароль совпадает?]
   │         │
   │         ├─ Нет ──► [Ошибка "Неверный пароль"] ──► [Возврат формы с ошибкой]
   │         │
   │         └─ Да ──► [Проверка статуса пользователя]
   │
   ├──► [Пользователь активен?]
   │         │
   │         ├─ Нет ──► [Ошибка "Аккаунт отключен"] ──► [Возврат формы с ошибкой]
   │         │
   │         └─ Да ──► [Создание сессии в Django]
   │
   ├──► [Запись в журнал аудита]
   │
   ├──► [Проверка redirectURL]
   │         │
   │         ├─ Есть параметр next ──► [Перенаправление по next]
   │         │
   │         └─ Нет параметра next ──► [Перенаправление на страницу Номенклатуры]
   │
   └──► [Конец]
```

**Схема авторизации в IntBus:**
```
[Начало]
   │
   ├──► [Проверка текущей сессии] ──► [Пользователь уже авторизован?]
   │                                      │
   │                                      ├─ Да ──► [Перенаправление на страницу синхронизации]
   │                                      │
   │                                      └─ Нет ──► [Отображение формы логина]
   │
   ├──► [Пользователь отправляет форму (POST)]
   │
   ├──► [Проверка заполнения полей] ──► [Поля заполнены?]
   │                                       │
   │                                       ├─ Нет ──► [Ошибка валидации формы] ──► [Возврат формы с ошибками]
   │                                       │
   │                                       └─ Да ──► [Поиск пользователя в БД]
   │
   ├──► [Пользователь найден?]
   │         │
   │         ├─ Нет ──► [Ошибка "Неверное имя пользователя"] ──► [Возврат формы с ошибкой]
   │         │
   │         └─ Да ──► [Проверка пароля]
   │
   ├──► [Пароль совпадает?]
   │         │
   │         ├─ Нет ──┬─► [Ошибка "Неверный пароль"] ──► [Возврат формы с ошибкой]
   │         │         │
   │         │         └─► [Увеличение счетчика попыток] ──► [Проверка блокировки аккаунта]
   │         │
   │         └─ Да ──► [Проверка статуса пользователя]
   │
   ├──► [Пользователь активен?]
   │         │
   │         ├─ Нет ──► [Ошибка "Аккаунт отключен"] ──► [Возврат формы с ошибкой]
   │         │
   │         └─ Да ──► [Создание сессии в Django] ──► [Сброс счетчика попыток]
   │
   ├──► [Проверка прав доступа]
   │         │
   │         ├─ Администратор ──► [Перенаправление на админ-панель]
   │         │
   │         ├─ Пользователь sync_app ──► [Перенаправление на страницу управления синхронизацией]
   │         │
   │         └─ Обычный пользователь ──► [Перенаправление на главную страницу]
   │
   └──► [Конец]
```

**Схема авторизации в TeamCenter:**
```
[Начало]
   │
   ├──► [Получение запроса на авторизацию]
   │
   ├──► [Валидация JWT токена/учетных данных]
   │
   ├──► [Проверка в базе данных пользователей]
   │
   ├──► [Генерация нового токена]
   │
   ├──► [Установка токена в cookies/заголовки]
   │
   ├──► [Перенаправление на главную страницу]
   │
   └──► [Конец]
```

**Алгоритмы работы страниц систем:**

Ниже представлены обобщенные алгоритмы работы страниц для просмотра и управления данными номенклатуры и ЛСИ в каждой из систем.

**Алгоритм работы страницы Номенклатуры в ATOM:**
```
[Начало]
   │
   ├──► [Проверка авторизации]
   │
   ├──► [Получение параметров фильтрации]
   │
   ├──► [Запрос к базе данных]
   │
   ├──► [Получение списка номенклатуры]
   │
   ├──► [Пагинация результатов]
   │
   ├──► [Подготовка данных для шаблона]
   │
   ├──► [Рендеринг страницы]
   │
   └──► [Конец]
```

**Алгоритм работы страницы ЛСИ в ATOM:**
```
[Начало]
   │
   ├──► [Проверка авторизации]
   │
   ├──► [Получение параметров фильтрации]
   │
   ├──► [Запрос к базе данных]
   │
   ├──► [Получение списка элементов ЛСИ]
   │
   ├──► [Формирование древовидной структуры]
   │
   ├──► [Подготовка данных для шаблона]
   │
   ├──► [Рендеринг страницы]
   │
   └──► [Конец]
```

**Алгоритм работы страницы Номенклатуры в IntBus:**
```
[Начало]
   │
   ├──► [Проверка авторизации]
   │
   ├──► [Получение параметров фильтрации]
   │
   ├──► [Запрос к базе данных]
   │
   ├──► [Получение списка номенклатуры]
   │
   ├──► [Получение статуса синхронизации]
   │
   ├──► [Пагинация результатов]
   │
   ├──► [Подготовка данных для шаблона]
   │
   ├──► [Рендеринг страницы]
   │
   └──► [Конец]
```

**Алгоритм работы страницы ЛСИ в IntBus:**
```
[Начало]
   │
   ├──► [Проверка авторизации]
   │
   ├──► [Получение параметров фильтрации]
   │
   ├──► [Запрос к базе данных]
   │
   ├──► [Получение списка элементов ЛСИ]
   │
   ├──► [Проверка статуса синхронизации]
   │
   ├──► [Формирование древовидной структуры]
   │
   ├──► [Подготовка данных для шаблона]
   │
   ├──► [Рендеринг страницы]
   │
   └──► [Конец]
```

**Алгоритм работы страницы Номенклатуры в TeamCenter:**
```
[Начало]
   │
   ├──► [Проверка авторизации по токену]
   │
   ├──► [Получение параметров из запроса]
   │
   ├──► [Запрос к REST API]
   │
   ├──► [Получение данных номенклатуры]
   │
   ├──► [Обработка полученных данных]
   │
   ├──► [Формирование React-компонентов]
   │
   ├──► [Рендеринг страницы в браузере]
   │
   └──► [Конец]
```

**Алгоритм работы страницы ЛСИ в TeamCenter:**
```
[Начало]
   │
   ├──► [Проверка авторизации по токену]
   │
   ├──► [Получение параметров из запроса]
   │
   ├──► [Запрос к REST API]
   │
   ├──► [Получение данных ЛСИ]
   │
   ├──► [Преобразование в древовидную структуру]
   │
   ├──► [Формирование React-компонентов]
   │
   ├──► [Рендеринг страницы в браузере]
   │
   └──► [Конец]
```

В отличие от систем на Django (`ATOM` и `IntBus`), где рендеринг страниц происходит на сервере, в системе `TeamCenter` используется клиентский рендеринг с помощью React. Кроме того, система `IntBus`, выполняющая роль интеграционного хаба, дополнительно отображает информацию о статусе синхронизации данных с другими системами.

    2.5 Отладка и тестирование программы

Отладка и тестирование являются критически важными этапами разработки интеграционного решения для обеспечения его надежности, корректности обработки данных и устойчивости к ошибкам.

**2.5.1 Отладка программы**
Отладка проводилась на всех этапах разработки с использованием стандартных средств:
*   **Python:** Использование отладчика `pdb` или отладчиков в IDE (например, PyCharm, VS Code) для пошагового выполнения кода `sync_app`, проверки значений переменных, анализа стека вызовов при ошибках.
*   **Java:** Использование отладчика в IDE (например, IntelliJ IDEA, Eclipse) для отладки кода `TeamCenter`, если он участвует в интеграции не только через БД/файлы.
*   **Логирование:** Активное использование модуля логирования Python (`logging`) и аналогичных средств в Java (Log4j, SLF4j) для записи подробной информации о ходе выполнения, значениях ключевых переменных и возникающих исключениях в файлы (`logs/debug.log`). Анализ логов позволяет быстро локализовать проблемы.
*   **Инструменты СУБД:** Использование клиентов для SQLite (DB Browser for SQLite) и H2 (H2 Console) для проверки состояния баз данных до и после выполнения интеграционных задач.

**2.5.2 Тестирование программы**
Процесс тестирования включал несколько уровней:

1.  **Модульное тестирование (Unit Testing):**
    *   Тестирование отдельных функций и классов `sync_app` (особенно логики трансформации данных, парсеров файлов) с использованием фреймворка `unittest` или `pytest` в Python.
    *   Проверка корректности работы коннекторов к БД на тестовых подключениях.
    *   Использование mock-объектов для изоляции тестируемых модулей.
2.  **Интеграционное тестирование (Integration Testing):**
    *   Проверка взаимодействия `sync_app` с реальными (или тестовыми) базами данных `ATOM`, `TeamCenter`, `IntBus`.
    *   Тестирование полного цикла ETL для различных потоков данных с использованием тестовых XML и Excel файлов.
    *   Проверка корректности записи данных в системы-приемники.
    *   Тестирование запуска по расписанию (если используется).
3.  **Тестирование обработки ошибок:**
    *   Имитация различных сбойных ситуаций: недоступность БД, некорректные данные в файлах, нарушение ограничений целостности в приемнике.
    *   Проверка корректности логирования ошибок и, при необходимости, отката изменений.
4.  **Тестирование в среде Docker:**
    *   Проверка сборки Docker-образов для всех компонентов (`ATOM`, `TeamCenter`, `IntBus`).
    *   Запуск всей системы с помощью Docker Compose (если используется).
    *   Проверка сетевого взаимодействия между контейнерами и доступа к общим томам (`data/`, `logs/`).

**Примеры тестовых сценариев:**
*   **Сценарий 1 (Успешная синхронизация):** Загрузка корректного XML файла с составом изделия из `ATOM`. Проверка, что данные успешно прочитаны, трансформированы и записаны в БД `IntBus`.
*   **Сценарий 2 (Ошибка данных):** Загрузка Excel файла с НСИ, содержащего некорректное значение в одном из полей. Проверка, что ошибка залогирована, а запись (или весь файл) не обработана (в зависимости от стратегии обработки ошибок).
*   **Сценарий 3 (Ошибка подключения):** Попытка синхронизации при недоступной БД `TeamCenter`. Проверка, что ошибка подключения залогирована, и система корректно обрабатывает эту ситуацию (например, повторяет попытку позже).

Примеры логов успешного выполнения и обработки ошибок приведены на рисунках 2.9 и 2.10.

*[Здесь должна быть Рисунок 2.9 – Пример лога успешной синхронизации]*
*[Здесь должна быть Рисунок 2.10 – Пример лога обработки ошибки данных]*

По результатам тестирования были выявлены и устранены [количество] ошибок. Программа признана работоспособной и соответствующей функциональным требованиям.

    2.6 Руководство пользователя

Данное руководство предназначено для администраторов и пользователей, отвечающих за эксплуатацию и мониторинг интеграционного решения между системами `ATOM`, `TeamCenter` и `IntBus`.

**2.6.1 Назначение программы**
Программный комплекс предназначен для автоматической синхронизации данных между информационными системами `ATOM`, `TeamCenter` и `IntBus` с целью обеспечения их консистентности и актуальности. Центральным компонентом является модуль `sync_app`, работающий в среде `IntBus`.

**2.6.2 Условия выполнения программы**
Для работы интеграционного решения необходимо:
*   **Аппаратное обеспечение:** Сервер (или виртуальная машина) с установленным Docker и Docker Compose (рекомендуется), соответствующий требованиям из раздела 1.4.4.
*   **Программное обеспечение:**
    *   Работающие Docker-контейнеры для `ATOM`, `TeamCenter`, `IntBus`.
    *   Наличие необходимых версий Python, Java, СУБД SQLite и H2 внутри контейнеров.
    *   Корректно настроенные сетевые подключения между контейнерами.
    *   Наличие и доступность директорий для обмена файлами (`data/`) и логирования (`logs/`), если они вынесены во внешние тома Docker.
*   **Конфигурация:** Наличие актуальных конфигурационных файлов или записей в БД `IntBus`, описывающих параметры интеграционных потоков (подключения, маппинг, расписание).

**2.6.3 Выполнение программы**
1.  **Запуск системы:**
    *   Убедитесь, что Docker и Docker Compose установлены и запущены.
    *   Перейдите в директорию с файлом `docker-compose.yml` (если используется).
    *   Запустите все контейнеры командой: `docker-compose up -d` (или запустите каждый контейнер отдельно командами `docker run ...`).
2.  **Проверка статуса:**
    *   Убедитесь, что все контейнеры успешно запустились: `docker ps`.
    *   Проверьте первичные логи контейнеров на наличие ошибок при запуске: `docker logs <container_name>`.
3.  **Настройка интеграции (если требуется):**
    *   При первом запуске или изменении логики интеграции может потребоваться настройка. Это делается [Описать способ: через админ-панель Django в IntBus / редактирование конфигурационных файлов]. См. рисунок 2.3 для примера интерфейса настройки.
4.  **Мониторинг:**
    *   **Автоматический режим:** Интеграционные задачи запускаются автоматически по расписанию (например, каждые N минут/часов).
    *   **Просмотр логов:** Регулярно проверяйте файлы логов (`logs/sync_app.log` или аналогичный) на наличие ошибок или предупреждений. Пример лога показан на рисунке 2.9.
    *   **Просмотр статуса (если есть UI):** Используйте интерфейс [Django Admin / React Frontend] для просмотра статуса последних выполнений задач. См. рисунки 2.3 и 2.4.
5.  **Ручной запуск (если требуется/возможно):**
    *   Некоторые задачи могут требовать ручного запуска. Это делается через [Описать способ: кнопка в UI / команда в Docker-контейнере IntBus].
6.  **Остановка системы:**
    *   Остановите контейнеры: `docker-compose down` (или `docker stop <container_name>` для каждого).

**2.6.4 Сообщения пользователю**
Основным способом информирования пользователя (администратора) о работе системы являются:
*   **Лог-файлы:** Содержат детальную информацию о ходе выполнения, обработанных данных, ошибках. Уровни логирования (DEBUG, INFO, WARNING, ERROR) позволяют фильтровать сообщения.
*   **Статус в UI (если есть):** Визуальное отображение результата последнего запуска (Успех/Ошибка/В процессе).
*   **Уведомления об ошибках (опционально):** Система может быть настроена на отправку уведомлений (например, по email) при возникновении критических ошибок.

При возникновении проблем в первую очередь следует анализировать лог-файлы модуля `sync_app`.

    2.7 Вывод по разделу

В данном разделе была описана разработка программного продукта для интеграции систем `ATOM`, `TeamCenter` и `IntBus`. Была представлена архитектура решения на основе центрального модуля `sync_app` и Docker-контейнеров. Рассмотрена структура данных, передаваемых между системами через базы данных и файлы обмена (XML, Excel). Описаны основные алгоритмы ETL и возможные варианты пользовательского интерфейса для управления интеграцией. Изложены подходы к отладке и тестированию, включая модульное, интеграционное тестирование и тестирование обработки ошибок. Представлено руководство пользователя по развертыванию, настройке и мониторингу работы интеграционного решения.

[Нужно добавить заключительный абзац, подводящий итог проделанной работы в разделе 2 и связывающий его со следующими разделами диплома]

ЗАКЛЮЧЕНИЕ

СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ 